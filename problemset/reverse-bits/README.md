# 颠倒二进制位

> 难度：简单
>
> https://leetcode-cn.com/problems/reverse-bits/

## 题目

颠倒给定的 32 位无符号整数的二进制位。

提示：

- 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出
  都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无
  符号的，其内部的二进制表示形式都是相同的。
- 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在 示例 2  中，输
  入表示有符号整数 -3，输出表示有符号整数 -1073741825。

### 示例

#### 示例 1：

```
输入：n = 00000010100101000001111010011100
输出：964176192 (00111001011110000010100101000000)
解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
```

#### 示例 2：

```
输入：n = 11111111111111111111111111111101
输出：3221225471 (10111111111111111111111111111111)
解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。
```

## 解题

### 逐位颠倒

```typescript
/**
 * 逐位颠倒
 * @desc 时间复杂度 O(logN)  空间复杂度 O(1)
 * @param n
 */
export function reverseBits(n: number): number {
  let rev = 0;
  for (let i = 0; i < 32 && n > 0; i++) {
    rev |= (n & 1) << (31 - i);
    n >>>= 1;
  }

  return rev >>> 0;
}
```

### 位运算分治

```typescript
/**
 * 位运算分治
 * @desc 时间复杂度 O(1)  空间复杂度 O(1)
 * @param n
 */
export function reverseBits2(n: number): number {
  const M1 = 0b01010101010101010101010101010101;
  const M2 = 0b00110011001100110011001100110011;
  const M4 = 0b00001111000011110000111100001111;
  const M8 = 0b00000000111111110000000011111111;

  /**
   * e.g:   00000010 10010100 00011110 10011100
   * step1: 00000001 01101000 00101101 01101100
   * step2: 00000100 10010010 10000111 10010011
   * step3: 01000000 00101001 01111000 00111001
   * step4: 00101001 01000000 00111001 01111000
   * step5: 00111001 01111000 00101001 01000000
   */

  n = ((n >>> 1) & M1) | ((n & M1) << 1);
  n = ((n >>> 2) & M2) | ((n & M2) << 2);
  n = ((n >>> 4) & M4) | ((n & M4) << 4);
  n = ((n >>> 8) & M8) | ((n & M8) << 8);
  return ((n >>> 16) | (n << 16)) >>> 0;
}
```

### 位运算分治
